var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{};function t(e,t,r,o){Object.defineProperty(e,t,{get:r,set:o,enumerable:!0,configurable:!0})}var r=e.parcelRequire726c,o=r.register;o("jezKP",function(e,t){var o=e.exports&&e.exports.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(e.exports,"__esModule",{value:!0});let n=o(r("dQaoa")),s=o(r("4r6Dt")),i=o(r("ah6Tu")),a=new s.default.Agent({keepAlive:!0}),u=new i.default.Agent({keepAlive:!0});e.exports.default=function(e,t){return(0,n.default)(e,Object.assign({agent:"http:"===new URL(e.toString()).protocol?a:u},t))}}),o("dQaoa",function(t,r){var o=function(){// the only reliable means to get the global object is
// `Function('return this')()`
// However, this causes CSP violations in Chrome apps.
if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==e)return e;throw Error("unable to locate global object")}();t.exports=r=o.fetch,o.fetch&&(r.default=o.fetch.bind(o)),r.Headers=o.Headers,r.Request=o.Request,r.Response=o.Response}),o("4r6Dt",function(t,o){var n=r("beyFQ"),s=r("iiJHK"),i=r("axiyR"),a=r("l3iXw"),u=r("eAyj5"),c=t.exports;c.request=function(t,r){t="string"==typeof t?u.parse(t):i(t);// Normally, the page is loaded from http or https, so not specifying a protocol
// will result in a (valid) protocol-relative url. However, this won't work if
// the protocol is something else, like 'file:'
var o=-1===e.location.protocol.search(/^https?:$/)?"http:":"",s=t.protocol||o,a=t.hostname||t.host,c=t.port,d=t.path||"/";a&&-1!==a.indexOf(":")&&(a="["+a+"]"),// This may be a relative url. The browser should always be able to interpret it correctly.
t.url=(a?s+"//"+a:"")+(c?":"+c:"")+d,t.method=(t.method||"GET").toUpperCase(),t.headers=t.headers||{};// Also valid opts.auth, opts.mode
var f=new n(t);return r&&f.on("response",r),f},c.get=function(e,t){var r=c.request(e,t);return r.end(),r},c.ClientRequest=n,c.IncomingMessage=s.IncomingMessage,c.Agent=function(){},c.Agent.defaultMaxSockets=4,c.globalAgent=new c.Agent,c.STATUS_CODES=a,c.METHODS=["CHECKOUT","CONNECT","COPY","DELETE","GET","HEAD","LOCK","M-SEARCH","MERGE","MKACTIVITY","MKCOL","MOVE","NOTIFY","OPTIONS","PATCH","POST","PROPFIND","PROPPATCH","PURGE","PUT","REPORT","SEARCH","SUBSCRIBE","TRACE","UNLOCK","UNSUBSCRIBE"]}),o("beyFQ",function(t,o){var n=r("bdjQ6").Buffer,s=r("4ZL0H"),i=r("7zO5M"),a=r("dhT4G"),u=r("iiJHK"),c=r("dFZZW"),d=u.IncomingMessage,f=u.readyStates,l=t.exports=function(e){var t,r,o,s=this;c.Writable.call(s),s._opts=e,s._body=[],s._headers={},e.auth&&s.setHeader("Authorization","Basic "+n.from(e.auth).toString("base64")),Object.keys(e.headers).forEach(function(t){s.setHeader(t,e.headers[t])});var a=!0;if("disable-fetch"===e.mode||"requestTimeout"in e&&!i.abortController)// If the use of XHR should be preferred. Not typically needed.
a=!1,o=!0;else if("prefer-streaming"===e.mode)// the accuracy of the 'content-type' header aren't
o=!1;else if("allow-wrong-content-type"===e.mode)o=!i.overrideMimeType;else if(e.mode&&"default"!==e.mode&&"prefer-fast"!==e.mode)throw Error("Invalid value for opts.mode");else o=!0;s._mode=(t=o,r=a,i.fetch&&r?"fetch":i.mozchunkedarraybuffer?"moz-chunked-arraybuffer":i.msstream?"ms-stream":i.arraybuffer&&t?"arraybuffer":"text"),s._fetchTimer=null,s._socketTimeout=null,s._socketTimer=null,s.on("finish",function(){s._onFinish()})};a(l,c.Writable),l.prototype.setHeader=function(e,t){var r=e.toLowerCase();// This check is not necessary, but it prevents warnings from browsers about setting unsafe
// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
// http-browserify did it, so I will too.
-1===p.indexOf(r)&&(this._headers[r]={name:e,value:t})},l.prototype.getHeader=function(e){var t=this._headers[e.toLowerCase()];return t?t.value:null},l.prototype.removeHeader=function(e){delete this._headers[e.toLowerCase()]},l.prototype._onFinish=function(){var t=this;if(!t._destroyed){var r=t._opts;"timeout"in r&&0!==r.timeout&&t.setTimeout(r.timeout);var o=t._headers,n=null;"GET"!==r.method&&"HEAD"!==r.method&&(n=new Blob(t._body,{type:(o["content-type"]||{}).value||""}));// create flattened list of headers
var a=[];if(Object.keys(o).forEach(function(e){var t=o[e].name,r=o[e].value;Array.isArray(r)?r.forEach(function(e){a.push([t,e])}):a.push([t,r])}),"fetch"===t._mode){var u=null;if(i.abortController){var c=new AbortController;u=c.signal,t._fetchAbortController=c,"requestTimeout"in r&&0!==r.requestTimeout&&(t._fetchTimer=e.setTimeout(function(){t.emit("requestTimeout"),t._fetchAbortController&&t._fetchAbortController.abort()},r.requestTimeout))}e.fetch(t._opts.url,{method:t._opts.method,headers:a,body:n||void 0,mode:"cors",credentials:r.withCredentials?"include":"same-origin",signal:u}).then(function(e){t._fetchResponse=e,t._resetTimers(!1),t._connect()},function(e){t._resetTimers(!0),t._destroyed||t.emit("error",e)})}else{var d=t._xhr=new e.XMLHttpRequest;try{d.open(t._opts.method,t._opts.url,!0)}catch(e){s.nextTick(function(){t.emit("error",e)});return}"responseType"in d&&(d.responseType=t._mode),"withCredentials"in d&&(d.withCredentials=!!r.withCredentials),"text"===t._mode&&"overrideMimeType"in d&&d.overrideMimeType("text/plain; charset=x-user-defined"),"requestTimeout"in r&&(d.timeout=r.requestTimeout,d.ontimeout=function(){t.emit("requestTimeout")}),a.forEach(function(e){d.setRequestHeader(e[0],e[1])}),t._response=null,d.onreadystatechange=function(){switch(d.readyState){case f.LOADING:case f.DONE:t._onXHRProgress()}},"moz-chunked-arraybuffer"===t._mode&&(d.onprogress=function(){t._onXHRProgress()}),d.onerror=function(){t._destroyed||(t._resetTimers(!0),t.emit("error",Error("XHR error")))};try{d.send(n)}catch(e){s.nextTick(function(){t.emit("error",e)});return}}}},l.prototype._onXHRProgress=function(){this._resetTimers(!1),/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */function(e){try{var t=e.status;return null!==t&&0!==t}catch(e){return!1}}(this._xhr)&&!this._destroyed&&(this._response||this._connect(),this._response._onXHRProgress(this._resetTimers.bind(this)))},l.prototype._connect=function(){var e=this;e._destroyed||(e._response=new d(e._xhr,e._fetchResponse,e._mode,e._resetTimers.bind(e)),e._response.on("error",function(t){e.emit("error",t)}),e.emit("response",e._response))},l.prototype._write=function(e,t,r){this._body.push(e),r()},l.prototype._resetTimers=function(t){var r=this;e.clearTimeout(r._socketTimer),r._socketTimer=null,t?(e.clearTimeout(r._fetchTimer),r._fetchTimer=null):r._socketTimeout&&(r._socketTimer=e.setTimeout(function(){r.emit("timeout")},r._socketTimeout))},l.prototype.abort=l.prototype.destroy=function(e){this._destroyed=!0,this._resetTimers(!0),this._response&&(this._response._destroyed=!0),this._xhr?this._xhr.abort():this._fetchAbortController&&this._fetchAbortController.abort(),e&&this.emit("error",e)},l.prototype.end=function(e,t,r){"function"==typeof e&&(r=e,e=void 0),c.Writable.prototype.end.call(this,e,t,r)},l.prototype.setTimeout=function(e,t){t&&this.once("timeout",t),this._socketTimeout=e,this._resetTimers(!1)},l.prototype.flushHeaders=function(){},l.prototype.setNoDelay=function(){},l.prototype.setSocketKeepAlive=function(){};// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var p=["accept-charset","accept-encoding","access-control-request-headers","access-control-request-method","connection","content-length","cookie","cookie2","date","dnt","expect","host","keep-alive","origin","referer","te","trailer","transfer-encoding","upgrade","via"]}),o("7zO5M",function(r,o){var n,s,i,a,u,c,d,f;function l(){// Cache the xhr value
if(void 0!==f)return f;if(e.XMLHttpRequest){f=new e.XMLHttpRequest;// If XDomainRequest is available (ie only, where xhr might not work
// cross domain), use the page location. Otherwise use example.com
// Note: this doesn't actually make an http request.
try{f.open("GET",e.XDomainRequest?"/":"https://example.com")}catch(e){f=null}}else f=null;return f}function p(e){var t=l();if(!t)return!1;try{return t.responseType=e,t.responseType===e}catch(e){}return!1}function h(e){return"function"==typeof e}t(r.exports,"fetch",function(){return n},function(e){return n=e}),t(r.exports,"writableStream",function(){return s},function(e){return s=e}),t(r.exports,"abortController",function(){return i},function(e){return i=e}),t(r.exports,"arraybuffer",function(){return a},function(e){return a=e}),t(r.exports,"msstream",function(){return u},function(e){return u=e}),t(r.exports,"mozchunkedarraybuffer",function(){return c},function(e){return c=e}),t(r.exports,"overrideMimeType",function(){return d},function(e){return d=e}),n=h(e.fetch)&&h(e.ReadableStream),s=h(e.WritableStream),i=h(e.AbortController),a=n||p("arraybuffer"),u=!n&&p("ms-stream"),c=!n&&p("moz-chunked-arraybuffer"),d=n||!!l()&&h(l().overrideMimeType),f=null// Help gc
}),o("iiJHK",function(o,n){t(o.exports,"readyStates",function(){return s},function(e){return s=e}),t(o.exports,"IncomingMessage",function(){return i},function(e){return i=e});var s,i,a=r("4ZL0H"),u=r("bdjQ6").Buffer,c=r("7zO5M"),d=r("dhT4G"),f=r("dFZZW"),l=s={UNSENT:0,OPENED:1,HEADERS_RECEIVED:2,LOADING:3,DONE:4},p=i=function(e,t,r,o){var n=this;if(f.Readable.call(n),n._mode=r,n.headers={},n.rawHeaders=[],n.trailers={},n.rawTrailers=[],// Fake the 'close' event, but only once 'end' fires
n.on("end",function(){// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
a.nextTick(function(){n.emit("close")})}),"fetch"===r){if(n._fetchResponse=t,n.url=t.url,n.statusCode=t.status,n.statusMessage=t.statusText,t.headers.forEach(function(e,t){n.headers[t.toLowerCase()]=e,n.rawHeaders.push(t,e)}),c.writableStream){var s=new WritableStream({write:function(e){return o(!1),new Promise(function(t,r){n._destroyed?r():n.push(u.from(e))?t():n._resumeFetch=t})},close:function(){o(!0),n._destroyed||n.push(null)},abort:function(e){o(!0),n._destroyed||n.emit("error",e)}});try{t.body.pipeTo(s).catch(function(e){o(!0),n._destroyed||n.emit("error",e)});return}catch(e){}// pipeTo method isn't defined. Can't find a better way to feature test this
}// fallback for when writableStream or pipeTo aren't available
var i=t.body.getReader();!function e(){i.read().then(function(t){if(!n._destroyed){if(o(t.done),t.done){n.push(null);return}n.push(u.from(t.value)),e()}}).catch(function(e){o(!0),n._destroyed||n.emit("error",e)})}()}else if(n._xhr=e,n._pos=0,n.url=e.responseURL,n.statusCode=e.status,n.statusMessage=e.statusText,e.getAllResponseHeaders().split(/\r?\n/).forEach(function(e){var t=e.match(/^([^:]+):\s*(.*)/);if(t){var r=t[1].toLowerCase();"set-cookie"===r?(void 0===n.headers[r]&&(n.headers[r]=[]),n.headers[r].push(t[2])):void 0!==n.headers[r]?n.headers[r]+=", "+t[2]:n.headers[r]=t[2],n.rawHeaders.push(t[1],t[2])}}),n._charset="x-user-defined",!c.overrideMimeType){var d=n.rawHeaders["mime-type"];if(d){var l=d.match(/;\s*charset=([^;])(;|$)/);l&&(n._charset=l[1].toLowerCase())}n._charset||(n._charset="utf-8"// best guess
)}};d(p,f.Readable),p.prototype._read=function(){var e=this._resumeFetch;e&&(this._resumeFetch=null,e())},p.prototype._onXHRProgress=function(t){var r=this,o=r._xhr,n=null;switch(r._mode){case"text":if((n=o.responseText).length>r._pos){var s=n.substr(r._pos);if("x-user-defined"===r._charset){for(var i=u.alloc(s.length),a=0;a<s.length;a++)i[a]=255&s.charCodeAt(a);r.push(i)}else r.push(s,r._charset);r._pos=n.length}break;case"arraybuffer":if(o.readyState!==l.DONE||!o.response)break;n=o.response,r.push(u.from(new Uint8Array(n)));break;case"moz-chunked-arraybuffer":if(n=o.response,o.readyState!==l.LOADING||!n)break;r.push(u.from(new Uint8Array(n)));break;case"ms-stream":if(n=o.response,o.readyState!==l.LOADING)break;var c=new e.MSStreamReader;c.onprogress=function(){c.result.byteLength>r._pos&&(r.push(u.from(new Uint8Array(c.result.slice(r._pos)))),r._pos=c.result.byteLength)},c.onload=function(){t(!0),r.push(null)},// reader.onerror = ??? // TODO: this
c.readAsArrayBuffer(n)}// The ms-stream case handles end separately in reader.onload()
r._xhr.readyState===l.DONE&&"ms-stream"!==r._mode&&(t(!0),r.push(null))}}),o("axiyR",function(e,t){e.exports=function(){for(var e={},t=0;t<arguments.length;t++){var o=arguments[t];for(var n in o)r.call(o,n)&&(e[n]=o[n])}return e};var r=Object.prototype.hasOwnProperty}),o("l3iXw",function(e,t){e.exports={100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi-Status",208:"Already Reported",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",308:"Permanent Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",416:"Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Unordered Collection",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",508:"Loop Detected",509:"Bandwidth Limit Exceeded",510:"Not Extended",511:"Network Authentication Required"}}),o("ah6Tu",function(e,t){var o=r("4r6Dt"),n=r("eAyj5"),s=e.exports;for(var i in o)o.hasOwnProperty(i)&&(s[i]=o[i]);function a(e){if("string"==typeof e&&(e=n.parse(e)),e.protocol||(e.protocol="https:"),"https:"!==e.protocol)throw Error('Protocol "'+e.protocol+'" not supported. Expected "https:"');return e}s.request=function(e,t){return e=a(e),o.request.call(this,e,t)},s.get=function(e,t){return e=a(e),o.get.call(this,e,t)}});//# sourceMappingURL=fetch.9910b35b.js.map

//# sourceMappingURL=fetch.9910b35b.js.map
